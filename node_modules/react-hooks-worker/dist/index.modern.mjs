import{useState as r,useMemo as e,useRef as t,useEffect as n}from"react";const o={};function s(s,a,l){const[i,u]=r(o),c=e(s,[s]),f=t(c);return n(()=>{f.current=c;let r=r=>u(r);return c.onmessage=e=>r({result:e.data}),c.onerror=()=>r({error:"error"}),c.onmessageerror=()=>r({error:"messageerror"}),()=>{r=()=>null,c.terminate(),u(o)}},[c]),n(()=>{f.current.postMessage(a,null==l?void 0:l())},[a,l]),i}function a(r){function e(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var e=r.done;return Promise.resolve(r.value).then(function(r){return{value:r,done:e}})}return a=function(r){this.s=r,this.n=r.next},a.prototype={s:null,n:null,next:function(){return e(this.n.apply(this.s,arguments))},return:function(r){var t=this.s.return;return void 0===t?Promise.resolve({value:r,done:!0}):e(t.apply(this.s,arguments))},throw:function(r){var t=this.s.return;return void 0===t?Promise.reject(r):e(t.apply(this.s,arguments))}},new a(r)}function l(r,e){self.onmessage=async t=>{const n=r(t.data);if(n&&n[Symbol.asyncIterator]){var o,s=!1,l=!1;try{for(var i,u=function(r){var e,t,n,o=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,n=Symbol.iterator);o--;){if(t&&null!=(e=r[t]))return e.call(r);if(n&&null!=(e=r[n]))return new a(e.call(r));t="@@asyncIterator",n="@@iterator"}throw new TypeError("Object is not async iterable")}(n);s=!(i=await u.next()).done;s=!1)self.postMessage(i.value,null==e?void 0:e())}catch(r){l=!0,o=r}finally{try{s&&null!=u.return&&await u.return()}finally{if(l)throw o}}}else if(n&&n[Symbol.iterator])for(const r of n)self.postMessage(r,null==e?void 0:e());else self.postMessage(await n,null==e?void 0:e())}}export{l as exposeWorker,s as useWorker};
//# sourceMappingURL=index.modern.mjs.map
